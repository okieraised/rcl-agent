// Code generated by ros2gen. DO NOT EDIT.

package rcl_interfaces_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <rcl_interfaces/msg/parameter_descriptor.h>

*/
import "C"

func init() {
	humble.RegisterMessage("rcl_interfaces/ParameterDescriptor", ParameterDescriptorTypeSupport)
	humble.RegisterMessage("rcl_interfaces/msg/ParameterDescriptor", ParameterDescriptorTypeSupport)
}

type ParameterDescriptor struct {
	Name                  string               `yaml:"name"`                   // The name of the parameter.
	Type                  uint8                `yaml:"type"`                   // Enum values are defined in the `ParameterType.msg` message.
	Description           string               `yaml:"description"`            // Description of the parameter, visible from introspection tools.
	AdditionalConstraints string               `yaml:"additional_constraints"` // Plain English description of additional constraints which cannot be expressedwith the available constraints, e.g. "only prime numbers".By convention, this should only be used to clarify constraints which cannotbe completely expressed with the parameter constraints below.
	ReadOnly              bool                 `yaml:"read_only"`              // If 'true' then the value cannot change after it has been initialized.
	DynamicTyping         bool                 `yaml:"dynamic_typing"`         // If true, the parameter is allowed to change type.
	FloatingPointRange    []FloatingPointRange `yaml:"floating_point_range"`   // FloatingPointRange consists of a from_value, a to_value, and a step.
	IntegerRange          []IntegerRange       `yaml:"integer_range"`          // IntegerRange consists of a from_value, a to_value, and a step.
}

// NewParameterDescriptor creates a new ParameterDescriptor with default values.
func NewParameterDescriptor() *ParameterDescriptor {
	self := ParameterDescriptor{}
	self.SetDefaults()
	return &self
}

func (t *ParameterDescriptor) Clone() *ParameterDescriptor {
	c := &ParameterDescriptor{}
	c.Name = t.Name
	c.Type = t.Type
	c.Description = t.Description
	c.AdditionalConstraints = t.AdditionalConstraints
	c.ReadOnly = t.ReadOnly
	c.DynamicTyping = t.DynamicTyping
	if t.FloatingPointRange != nil {
		c.FloatingPointRange = make([]FloatingPointRange, len(t.FloatingPointRange))
		CloneFloatingPointRangeSlice(c.FloatingPointRange, t.FloatingPointRange)
	}
	if t.IntegerRange != nil {
		c.IntegerRange = make([]IntegerRange, len(t.IntegerRange))
		CloneIntegerRangeSlice(c.IntegerRange, t.IntegerRange)
	}
	return c
}

func (t *ParameterDescriptor) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *ParameterDescriptor) SetDefaults() {
	t.Name = ""
	t.Type = 0
	t.Description = ""
	t.AdditionalConstraints = ""
	t.ReadOnly = false
	t.DynamicTyping = false
	t.FloatingPointRange = nil
	t.IntegerRange = nil
}

func (t *ParameterDescriptor) GetTypeSupport() humble.MessageTypeSupport {
	return ParameterDescriptorTypeSupport
}

// ParameterDescriptorPublisher wraps humble.Publisher to provide type safe helper
// functions
type ParameterDescriptorPublisher struct {
	*humble.Publisher
}

// NewParameterDescriptorPublisher creates and returns a new publisher for the
// ParameterDescriptor
func NewParameterDescriptorPublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*ParameterDescriptorPublisher, error) {
	pub, err := node.NewPublisher(topicName, ParameterDescriptorTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ParameterDescriptorPublisher{pub}, nil
}

func (p *ParameterDescriptorPublisher) Publish(msg *ParameterDescriptor) error {
	return p.Publisher.Publish(msg)
}

// ParameterDescriptorSubscription wraps humble.Subscription to provide type safe helper
// functions
type ParameterDescriptorSubscription struct {
	*humble.Subscription
}

// ParameterDescriptorSubscriptionCallback type is used to provide a subscription
// handler function for a ParameterDescriptorSubscription.
type ParameterDescriptorSubscriptionCallback func(msg *ParameterDescriptor, info *humble.MessageInfo, err error)

// NewParameterDescriptorSubscription creates and returns a new subscription for the
// ParameterDescriptor
func NewParameterDescriptorSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback ParameterDescriptorSubscriptionCallback) (*ParameterDescriptorSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg ParameterDescriptor
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, ParameterDescriptorTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ParameterDescriptorSubscription{sub}, nil
}

func (s *ParameterDescriptorSubscription) TakeMessage(out *ParameterDescriptor) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneParameterDescriptorSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneParameterDescriptorSlice(dst, src []ParameterDescriptor) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ParameterDescriptorTypeSupport humble.MessageTypeSupport = _ParameterDescriptorTypeSupport{}

type _ParameterDescriptorTypeSupport struct{}

func (t _ParameterDescriptorTypeSupport) New() humble.Message {
	return NewParameterDescriptor()
}

func (t _ParameterDescriptorTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.rcl_interfaces__msg__ParameterDescriptor
	return (unsafe.Pointer)(C.rcl_interfaces__msg__ParameterDescriptor__create())
}

func (t _ParameterDescriptorTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.rcl_interfaces__msg__ParameterDescriptor__destroy((*C.rcl_interfaces__msg__ParameterDescriptor)(pointer_to_free))
}

func (t _ParameterDescriptorTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*ParameterDescriptor)
	mem := (*C.rcl_interfaces__msg__ParameterDescriptor)(dst)
	humble.StringAsCStruct(unsafe.Pointer(&mem.name), m.Name)
	mem._type = C.uint8_t(m.Type)
	humble.StringAsCStruct(unsafe.Pointer(&mem.description), m.Description)
	humble.StringAsCStruct(unsafe.Pointer(&mem.additional_constraints), m.AdditionalConstraints)
	mem.read_only = C.bool(m.ReadOnly)
	mem.dynamic_typing = C.bool(m.DynamicTyping)
	FloatingPointRangeSequenceToC(&mem.floating_point_range, m.FloatingPointRange)
	IntegerRangeSequenceToC(&mem.integer_range, m.IntegerRange)
}

func (t _ParameterDescriptorTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*ParameterDescriptor)
	mem := (*C.rcl_interfaces__msg__ParameterDescriptor)(ros2_message_buffer)
	humble.StringAsGoStruct(&m.Name, unsafe.Pointer(&mem.name))
	m.Type = uint8(mem._type)
	humble.StringAsGoStruct(&m.Description, unsafe.Pointer(&mem.description))
	humble.StringAsGoStruct(&m.AdditionalConstraints, unsafe.Pointer(&mem.additional_constraints))
	m.ReadOnly = bool(mem.read_only)
	m.DynamicTyping = bool(mem.dynamic_typing)
	FloatingPointRangeSequenceToGo(&m.FloatingPointRange, mem.floating_point_range)
	IntegerRangeSequenceToGo(&m.IntegerRange, mem.integer_range)
}

func (t _ParameterDescriptorTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__rcl_interfaces__msg__ParameterDescriptor())
}

type CParameterDescriptor = C.rcl_interfaces__msg__ParameterDescriptor
type CParameterDescriptorSequence = C.rcl_interfaces__msg__ParameterDescriptor__Sequence

func ParameterDescriptorSequenceToGo(goSlice *[]ParameterDescriptor, cSlice CParameterDescriptorSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]ParameterDescriptor, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ParameterDescriptorTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func ParameterDescriptorSequenceToC(cSlice *CParameterDescriptorSequence, goSlice []ParameterDescriptor) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rcl_interfaces__msg__ParameterDescriptor)(C.malloc(C.sizeof_struct_rcl_interfaces__msg__ParameterDescriptor * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ParameterDescriptorTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func ParameterDescriptorArrayToGo(goSlice []ParameterDescriptor, cSlice []CParameterDescriptor) {
	for i := 0; i < len(cSlice); i++ {
		ParameterDescriptorTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func ParameterDescriptorArrayToC(cSlice []CParameterDescriptor, goSlice []ParameterDescriptor) {
	for i := 0; i < len(goSlice); i++ {
		ParameterDescriptorTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
