// Code generated by ros2gen. DO NOT EDIT.

package rcl_interfaces_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <rcl_interfaces/msg/integer_range.h>

*/
import "C"

func init() {
	humble.RegisterMessage("rcl_interfaces/IntegerRange", IntegerRangeTypeSupport)
	humble.RegisterMessage("rcl_interfaces/msg/IntegerRange", IntegerRangeTypeSupport)
}

type IntegerRange struct {
	FromValue int64  `yaml:"from_value"` // Start value for valid values, inclusive.
	ToValue   int64  `yaml:"to_value"`   // End value for valid values, inclusive.
	Step      uint64 `yaml:"step"`       // Size of valid steps between the from and to bound.A step value of zero implies a continuous range of values. Ideally, the stepwould be less than or equal to the distance between the bounds, as well as aneven multiple of the distance between the bounds, but neither are required.If the absolute value of the step is larger than or equal to the distancebetween the two bounds, then the bounds will be the only valid values. e.g. ifthe range is defined as {from_value: 1, to_value: 2, step: 5} then the validvalues will be 1 and 2.If the step is less than the distance between the bounds, but the distance isnot a multiple of the step, then the "to" bound will always be a valid value,e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} thenthe valid values will be 2, 4, and 5.
}

// NewIntegerRange creates a new IntegerRange with default values.
func NewIntegerRange() *IntegerRange {
	self := IntegerRange{}
	self.SetDefaults()
	return &self
}

func (t *IntegerRange) Clone() *IntegerRange {
	c := &IntegerRange{}
	c.FromValue = t.FromValue
	c.ToValue = t.ToValue
	c.Step = t.Step
	return c
}

func (t *IntegerRange) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *IntegerRange) SetDefaults() {
	t.FromValue = 0
	t.ToValue = 0
	t.Step = 0
}

func (t *IntegerRange) GetTypeSupport() humble.MessageTypeSupport {
	return IntegerRangeTypeSupport
}

// IntegerRangePublisher wraps humble.Publisher to provide type safe helper
// functions
type IntegerRangePublisher struct {
	*humble.Publisher
}

// NewIntegerRangePublisher creates and returns a new publisher for the
// IntegerRange
func NewIntegerRangePublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*IntegerRangePublisher, error) {
	pub, err := node.NewPublisher(topicName, IntegerRangeTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &IntegerRangePublisher{pub}, nil
}

func (p *IntegerRangePublisher) Publish(msg *IntegerRange) error {
	return p.Publisher.Publish(msg)
}

// IntegerRangeSubscription wraps humble.Subscription to provide type safe helper
// functions
type IntegerRangeSubscription struct {
	*humble.Subscription
}

// IntegerRangeSubscriptionCallback type is used to provide a subscription
// handler function for a IntegerRangeSubscription.
type IntegerRangeSubscriptionCallback func(msg *IntegerRange, info *humble.MessageInfo, err error)

// NewIntegerRangeSubscription creates and returns a new subscription for the
// IntegerRange
func NewIntegerRangeSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback IntegerRangeSubscriptionCallback) (*IntegerRangeSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg IntegerRange
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, IntegerRangeTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &IntegerRangeSubscription{sub}, nil
}

func (s *IntegerRangeSubscription) TakeMessage(out *IntegerRange) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneIntegerRangeSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneIntegerRangeSlice(dst, src []IntegerRange) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var IntegerRangeTypeSupport humble.MessageTypeSupport = _IntegerRangeTypeSupport{}

type _IntegerRangeTypeSupport struct{}

func (t _IntegerRangeTypeSupport) New() humble.Message {
	return NewIntegerRange()
}

func (t _IntegerRangeTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.rcl_interfaces__msg__IntegerRange
	return (unsafe.Pointer)(C.rcl_interfaces__msg__IntegerRange__create())
}

func (t _IntegerRangeTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.rcl_interfaces__msg__IntegerRange__destroy((*C.rcl_interfaces__msg__IntegerRange)(pointer_to_free))
}

func (t _IntegerRangeTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*IntegerRange)
	mem := (*C.rcl_interfaces__msg__IntegerRange)(dst)
	mem.from_value = C.int64_t(m.FromValue)
	mem.to_value = C.int64_t(m.ToValue)
	mem.step = C.uint64_t(m.Step)
}

func (t _IntegerRangeTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*IntegerRange)
	mem := (*C.rcl_interfaces__msg__IntegerRange)(ros2_message_buffer)
	m.FromValue = int64(mem.from_value)
	m.ToValue = int64(mem.to_value)
	m.Step = uint64(mem.step)
}

func (t _IntegerRangeTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__rcl_interfaces__msg__IntegerRange())
}

type CIntegerRange = C.rcl_interfaces__msg__IntegerRange
type CIntegerRangeSequence = C.rcl_interfaces__msg__IntegerRange__Sequence

func IntegerRangeSequenceToGo(goSlice *[]IntegerRange, cSlice CIntegerRangeSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]IntegerRange, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		IntegerRangeTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func IntegerRangeSequenceToC(cSlice *CIntegerRangeSequence, goSlice []IntegerRange) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rcl_interfaces__msg__IntegerRange)(C.malloc(C.sizeof_struct_rcl_interfaces__msg__IntegerRange * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		IntegerRangeTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func IntegerRangeArrayToGo(goSlice []IntegerRange, cSlice []CIntegerRange) {
	for i := 0; i < len(cSlice); i++ {
		IntegerRangeTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func IntegerRangeArrayToC(cSlice []CIntegerRange, goSlice []IntegerRange) {
	for i := 0; i < len(goSlice); i++ {
		IntegerRangeTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
