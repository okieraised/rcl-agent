// Code generated by ros2gen. DO NOT EDIT.

package rcl_interfaces_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <rcl_interfaces/msg/floating_point_range.h>

*/
import "C"

func init() {
	humble.RegisterMessage("rcl_interfaces/FloatingPointRange", FloatingPointRangeTypeSupport)
	humble.RegisterMessage("rcl_interfaces/msg/FloatingPointRange", FloatingPointRangeTypeSupport)
}

type FloatingPointRange struct {
	FromValue float64 `yaml:"from_value"` // Start value for valid values, inclusive.
	ToValue   float64 `yaml:"to_value"`   // End value for valid values, inclusive.
	Step      float64 `yaml:"step"`       // Size of valid steps between the from and to bound.Step is considered to be a magnitude, therefore negative values are treatedthe same as positive values, and a step value of zero implies a continuousrange of values.Ideally, the step would be less than or equal to the distance between thebounds, as well as an even multiple of the distance between the bounds, butneither are required.If the absolute value of the step is larger than or equal to the distancebetween the two bounds, then the bounds will be the only valid values. e.g. ifthe range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then thevalid values will be 1.0 and 2.0.If the step is less than the distance between the bounds, but the distance isnot a multiple of the step, then the "to" bound will always be a valid value,e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}then the valid values will be 2.0, 4.0, and 5.0.
}

// NewFloatingPointRange creates a new FloatingPointRange with default values.
func NewFloatingPointRange() *FloatingPointRange {
	self := FloatingPointRange{}
	self.SetDefaults()
	return &self
}

func (t *FloatingPointRange) Clone() *FloatingPointRange {
	c := &FloatingPointRange{}
	c.FromValue = t.FromValue
	c.ToValue = t.ToValue
	c.Step = t.Step
	return c
}

func (t *FloatingPointRange) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *FloatingPointRange) SetDefaults() {
	t.FromValue = 0
	t.ToValue = 0
	t.Step = 0
}

func (t *FloatingPointRange) GetTypeSupport() humble.MessageTypeSupport {
	return FloatingPointRangeTypeSupport
}

// FloatingPointRangePublisher wraps humble.Publisher to provide type safe helper
// functions
type FloatingPointRangePublisher struct {
	*humble.Publisher
}

// NewFloatingPointRangePublisher creates and returns a new publisher for the
// FloatingPointRange
func NewFloatingPointRangePublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*FloatingPointRangePublisher, error) {
	pub, err := node.NewPublisher(topicName, FloatingPointRangeTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &FloatingPointRangePublisher{pub}, nil
}

func (p *FloatingPointRangePublisher) Publish(msg *FloatingPointRange) error {
	return p.Publisher.Publish(msg)
}

// FloatingPointRangeSubscription wraps humble.Subscription to provide type safe helper
// functions
type FloatingPointRangeSubscription struct {
	*humble.Subscription
}

// FloatingPointRangeSubscriptionCallback type is used to provide a subscription
// handler function for a FloatingPointRangeSubscription.
type FloatingPointRangeSubscriptionCallback func(msg *FloatingPointRange, info *humble.MessageInfo, err error)

// NewFloatingPointRangeSubscription creates and returns a new subscription for the
// FloatingPointRange
func NewFloatingPointRangeSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback FloatingPointRangeSubscriptionCallback) (*FloatingPointRangeSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg FloatingPointRange
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, FloatingPointRangeTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &FloatingPointRangeSubscription{sub}, nil
}

func (s *FloatingPointRangeSubscription) TakeMessage(out *FloatingPointRange) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneFloatingPointRangeSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneFloatingPointRangeSlice(dst, src []FloatingPointRange) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var FloatingPointRangeTypeSupport humble.MessageTypeSupport = _FloatingPointRangeTypeSupport{}

type _FloatingPointRangeTypeSupport struct{}

func (t _FloatingPointRangeTypeSupport) New() humble.Message {
	return NewFloatingPointRange()
}

func (t _FloatingPointRangeTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.rcl_interfaces__msg__FloatingPointRange
	return (unsafe.Pointer)(C.rcl_interfaces__msg__FloatingPointRange__create())
}

func (t _FloatingPointRangeTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.rcl_interfaces__msg__FloatingPointRange__destroy((*C.rcl_interfaces__msg__FloatingPointRange)(pointer_to_free))
}

func (t _FloatingPointRangeTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*FloatingPointRange)
	mem := (*C.rcl_interfaces__msg__FloatingPointRange)(dst)
	mem.from_value = C.double(m.FromValue)
	mem.to_value = C.double(m.ToValue)
	mem.step = C.double(m.Step)
}

func (t _FloatingPointRangeTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*FloatingPointRange)
	mem := (*C.rcl_interfaces__msg__FloatingPointRange)(ros2_message_buffer)
	m.FromValue = float64(mem.from_value)
	m.ToValue = float64(mem.to_value)
	m.Step = float64(mem.step)
}

func (t _FloatingPointRangeTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__rcl_interfaces__msg__FloatingPointRange())
}

type CFloatingPointRange = C.rcl_interfaces__msg__FloatingPointRange
type CFloatingPointRangeSequence = C.rcl_interfaces__msg__FloatingPointRange__Sequence

func FloatingPointRangeSequenceToGo(goSlice *[]FloatingPointRange, cSlice CFloatingPointRangeSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FloatingPointRange, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		FloatingPointRangeTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func FloatingPointRangeSequenceToC(cSlice *CFloatingPointRangeSequence, goSlice []FloatingPointRange) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rcl_interfaces__msg__FloatingPointRange)(C.malloc(C.sizeof_struct_rcl_interfaces__msg__FloatingPointRange * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		FloatingPointRangeTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func FloatingPointRangeArrayToGo(goSlice []FloatingPointRange, cSlice []CFloatingPointRange) {
	for i := 0; i < len(cSlice); i++ {
		FloatingPointRangeTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func FloatingPointRangeArrayToC(cSlice []CFloatingPointRange, goSlice []FloatingPointRange) {
	for i := 0; i < len(goSlice); i++ {
		FloatingPointRangeTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
