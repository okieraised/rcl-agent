// Code generated by ros2gen. DO NOT EDIT.

package unitree_go_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <unitree_go/msg/lidar_state.h>

*/
import "C"

func init() {
	humble.RegisterMessage("unitree_go/LidarState", LidarStateTypeSupport)
	humble.RegisterMessage("unitree_go/msg/LidarState", LidarStateTypeSupport)
}

type LidarState struct {
	Stamp               float64    `yaml:"stamp"`
	FirmwareVersion     string     `yaml:"firmware_version"`
	SoftwareVersion     string     `yaml:"software_version"`
	SdkVersion          string     `yaml:"sdk_version"`
	SysRotationSpeed    float32    `yaml:"sys_rotation_speed"`
	ComRotationSpeed    float32    `yaml:"com_rotation_speed"`
	ErrorState          uint8      `yaml:"error_state"`
	CloudFrequency      float32    `yaml:"cloud_frequency"`
	CloudPacketLossRate float32    `yaml:"cloud_packet_loss_rate"`
	CloudSize           uint32     `yaml:"cloud_size"`
	CloudScanNum        uint32     `yaml:"cloud_scan_num"`
	ImuFrequency        float32    `yaml:"imu_frequency"`
	ImuPacketLossRate   float32    `yaml:"imu_packet_loss_rate"`
	ImuRpy              [3]float32 `yaml:"imu_rpy"`
	SerialRecvStamp     float64    `yaml:"serial_recv_stamp"`
	SerialBufferSize    uint32     `yaml:"serial_buffer_size"`
	SerialBufferRead    uint32     `yaml:"serial_buffer_read"`
}

// NewLidarState creates a new LidarState with default values.
func NewLidarState() *LidarState {
	self := LidarState{}
	self.SetDefaults()
	return &self
}

func (t *LidarState) Clone() *LidarState {
	c := &LidarState{}
	c.Stamp = t.Stamp
	c.FirmwareVersion = t.FirmwareVersion
	c.SoftwareVersion = t.SoftwareVersion
	c.SdkVersion = t.SdkVersion
	c.SysRotationSpeed = t.SysRotationSpeed
	c.ComRotationSpeed = t.ComRotationSpeed
	c.ErrorState = t.ErrorState
	c.CloudFrequency = t.CloudFrequency
	c.CloudPacketLossRate = t.CloudPacketLossRate
	c.CloudSize = t.CloudSize
	c.CloudScanNum = t.CloudScanNum
	c.ImuFrequency = t.ImuFrequency
	c.ImuPacketLossRate = t.ImuPacketLossRate
	c.ImuRpy = t.ImuRpy
	c.SerialRecvStamp = t.SerialRecvStamp
	c.SerialBufferSize = t.SerialBufferSize
	c.SerialBufferRead = t.SerialBufferRead
	return c
}

func (t *LidarState) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *LidarState) SetDefaults() {
	t.Stamp = 0
	t.FirmwareVersion = ""
	t.SoftwareVersion = ""
	t.SdkVersion = ""
	t.SysRotationSpeed = 0
	t.ComRotationSpeed = 0
	t.ErrorState = 0
	t.CloudFrequency = 0
	t.CloudPacketLossRate = 0
	t.CloudSize = 0
	t.CloudScanNum = 0
	t.ImuFrequency = 0
	t.ImuPacketLossRate = 0
	t.ImuRpy = [3]float32{}
	t.SerialRecvStamp = 0
	t.SerialBufferSize = 0
	t.SerialBufferRead = 0
}

func (t *LidarState) GetTypeSupport() humble.MessageTypeSupport {
	return LidarStateTypeSupport
}

// LidarStatePublisher wraps humble.Publisher to provide type safe helper
// functions
type LidarStatePublisher struct {
	*humble.Publisher
}

// NewLidarStatePublisher creates and returns a new publisher for the
// LidarState
func NewLidarStatePublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*LidarStatePublisher, error) {
	pub, err := node.NewPublisher(topicName, LidarStateTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &LidarStatePublisher{pub}, nil
}

func (p *LidarStatePublisher) Publish(msg *LidarState) error {
	return p.Publisher.Publish(msg)
}

// LidarStateSubscription wraps humble.Subscription to provide type safe helper
// functions
type LidarStateSubscription struct {
	*humble.Subscription
}

// LidarStateSubscriptionCallback type is used to provide a subscription
// handler function for a LidarStateSubscription.
type LidarStateSubscriptionCallback func(msg *LidarState, info *humble.MessageInfo, err error)

// NewLidarStateSubscription creates and returns a new subscription for the
// LidarState
func NewLidarStateSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback LidarStateSubscriptionCallback) (*LidarStateSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg LidarState
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, LidarStateTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &LidarStateSubscription{sub}, nil
}

func (s *LidarStateSubscription) TakeMessage(out *LidarState) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneLidarStateSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneLidarStateSlice(dst, src []LidarState) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var LidarStateTypeSupport humble.MessageTypeSupport = _LidarStateTypeSupport{}

type _LidarStateTypeSupport struct{}

func (t _LidarStateTypeSupport) New() humble.Message {
	return NewLidarState()
}

func (t _LidarStateTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.unitree_go__msg__LidarState
	return (unsafe.Pointer)(C.unitree_go__msg__LidarState__create())
}

func (t _LidarStateTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.unitree_go__msg__LidarState__destroy((*C.unitree_go__msg__LidarState)(pointer_to_free))
}

func (t _LidarStateTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*LidarState)
	mem := (*C.unitree_go__msg__LidarState)(dst)
	mem.stamp = C.double(m.Stamp)
	humble.StringAsCStruct(unsafe.Pointer(&mem.firmware_version), m.FirmwareVersion)
	humble.StringAsCStruct(unsafe.Pointer(&mem.software_version), m.SoftwareVersion)
	humble.StringAsCStruct(unsafe.Pointer(&mem.sdk_version), m.SdkVersion)
	mem.sys_rotation_speed = C.float(m.SysRotationSpeed)
	mem.com_rotation_speed = C.float(m.ComRotationSpeed)
	mem.error_state = C.uint8_t(m.ErrorState)
	mem.cloud_frequency = C.float(m.CloudFrequency)
	mem.cloud_packet_loss_rate = C.float(m.CloudPacketLossRate)
	mem.cloud_size = C.uint32_t(m.CloudSize)
	mem.cloud_scan_num = C.uint32_t(m.CloudScanNum)
	mem.imu_frequency = C.float(m.ImuFrequency)
	mem.imu_packet_loss_rate = C.float(m.ImuPacketLossRate)
	cSlice_imu_rpy := mem.imu_rpy[:]
	humble.Float32ArrayToC(*(*[]humble.CFloat32)(unsafe.Pointer(&cSlice_imu_rpy)), m.ImuRpy[:])
	mem.serial_recv_stamp = C.double(m.SerialRecvStamp)
	mem.serial_buffer_size = C.uint32_t(m.SerialBufferSize)
	mem.serial_buffer_read = C.uint32_t(m.SerialBufferRead)
}

func (t _LidarStateTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*LidarState)
	mem := (*C.unitree_go__msg__LidarState)(ros2_message_buffer)
	m.Stamp = float64(mem.stamp)
	humble.StringAsGoStruct(&m.FirmwareVersion, unsafe.Pointer(&mem.firmware_version))
	humble.StringAsGoStruct(&m.SoftwareVersion, unsafe.Pointer(&mem.software_version))
	humble.StringAsGoStruct(&m.SdkVersion, unsafe.Pointer(&mem.sdk_version))
	m.SysRotationSpeed = float32(mem.sys_rotation_speed)
	m.ComRotationSpeed = float32(mem.com_rotation_speed)
	m.ErrorState = uint8(mem.error_state)
	m.CloudFrequency = float32(mem.cloud_frequency)
	m.CloudPacketLossRate = float32(mem.cloud_packet_loss_rate)
	m.CloudSize = uint32(mem.cloud_size)
	m.CloudScanNum = uint32(mem.cloud_scan_num)
	m.ImuFrequency = float32(mem.imu_frequency)
	m.ImuPacketLossRate = float32(mem.imu_packet_loss_rate)
	cSlice_imu_rpy := mem.imu_rpy[:]
	humble.Float32ArrayToGo(m.ImuRpy[:], *(*[]humble.CFloat32)(unsafe.Pointer(&cSlice_imu_rpy)))
	m.SerialRecvStamp = float64(mem.serial_recv_stamp)
	m.SerialBufferSize = uint32(mem.serial_buffer_size)
	m.SerialBufferRead = uint32(mem.serial_buffer_read)
}

func (t _LidarStateTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__unitree_go__msg__LidarState())
}

type CLidarState = C.unitree_go__msg__LidarState
type CLidarStateSequence = C.unitree_go__msg__LidarState__Sequence

func LidarStateSequenceToGo(goSlice *[]LidarState, cSlice CLidarStateSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]LidarState, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		LidarStateTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func LidarStateSequenceToC(cSlice *CLidarStateSequence, goSlice []LidarState) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.unitree_go__msg__LidarState)(C.malloc(C.sizeof_struct_unitree_go__msg__LidarState * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		LidarStateTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func LidarStateArrayToGo(goSlice []LidarState, cSlice []CLidarState) {
	for i := 0; i < len(cSlice); i++ {
		LidarStateTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func LidarStateArrayToC(cSlice []CLidarState, goSlice []LidarState) {
	for i := 0; i < len(goSlice); i++ {
		LidarStateTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
