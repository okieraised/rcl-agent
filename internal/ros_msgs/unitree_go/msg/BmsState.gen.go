// Code generated by ros2gen. DO NOT EDIT.

package unitree_go_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <unitree_go/msg/bms_state.h>

*/
import "C"

func init() {
	humble.RegisterMessage("unitree_go/BmsState", BmsStateTypeSupport)
	humble.RegisterMessage("unitree_go/msg/BmsState", BmsStateTypeSupport)
}

type BmsState struct {
	VersionHigh uint8      `yaml:"version_high"`
	VersionLow  uint8      `yaml:"version_low"`
	Status      uint8      `yaml:"status"`
	Soc         uint8      `yaml:"soc"`
	Current     int32      `yaml:"current"`
	Cycle       uint16     `yaml:"cycle"`
	BqNtc       [2]int8    `yaml:"bq_ntc"`
	McuNtc      [2]int8    `yaml:"mcu_ntc"`
	CellVol     [15]uint16 `yaml:"cell_vol"`
}

// NewBmsState creates a new BmsState with default values.
func NewBmsState() *BmsState {
	self := BmsState{}
	self.SetDefaults()
	return &self
}

func (t *BmsState) Clone() *BmsState {
	c := &BmsState{}
	c.VersionHigh = t.VersionHigh
	c.VersionLow = t.VersionLow
	c.Status = t.Status
	c.Soc = t.Soc
	c.Current = t.Current
	c.Cycle = t.Cycle
	c.BqNtc = t.BqNtc
	c.McuNtc = t.McuNtc
	c.CellVol = t.CellVol
	return c
}

func (t *BmsState) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *BmsState) SetDefaults() {
	t.VersionHigh = 0
	t.VersionLow = 0
	t.Status = 0
	t.Soc = 0
	t.Current = 0
	t.Cycle = 0
	t.BqNtc = [2]int8{}
	t.McuNtc = [2]int8{}
	t.CellVol = [15]uint16{}
}

func (t *BmsState) GetTypeSupport() humble.MessageTypeSupport {
	return BmsStateTypeSupport
}

// BmsStatePublisher wraps humble.Publisher to provide type safe helper
// functions
type BmsStatePublisher struct {
	*humble.Publisher
}

// NewBmsStatePublisher creates and returns a new publisher for the
// BmsState
func NewBmsStatePublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*BmsStatePublisher, error) {
	pub, err := node.NewPublisher(topicName, BmsStateTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &BmsStatePublisher{pub}, nil
}

func (p *BmsStatePublisher) Publish(msg *BmsState) error {
	return p.Publisher.Publish(msg)
}

// BmsStateSubscription wraps humble.Subscription to provide type safe helper
// functions
type BmsStateSubscription struct {
	*humble.Subscription
}

// BmsStateSubscriptionCallback type is used to provide a subscription
// handler function for a BmsStateSubscription.
type BmsStateSubscriptionCallback func(msg *BmsState, info *humble.MessageInfo, err error)

// NewBmsStateSubscription creates and returns a new subscription for the
// BmsState
func NewBmsStateSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback BmsStateSubscriptionCallback) (*BmsStateSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg BmsState
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, BmsStateTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &BmsStateSubscription{sub}, nil
}

func (s *BmsStateSubscription) TakeMessage(out *BmsState) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneBmsStateSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneBmsStateSlice(dst, src []BmsState) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var BmsStateTypeSupport humble.MessageTypeSupport = _BmsStateTypeSupport{}

type _BmsStateTypeSupport struct{}

func (t _BmsStateTypeSupport) New() humble.Message {
	return NewBmsState()
}

func (t _BmsStateTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.unitree_go__msg__BmsState
	return (unsafe.Pointer)(C.unitree_go__msg__BmsState__create())
}

func (t _BmsStateTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.unitree_go__msg__BmsState__destroy((*C.unitree_go__msg__BmsState)(pointer_to_free))
}

func (t _BmsStateTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*BmsState)
	mem := (*C.unitree_go__msg__BmsState)(dst)
	mem.version_high = C.uint8_t(m.VersionHigh)
	mem.version_low = C.uint8_t(m.VersionLow)
	mem.status = C.uint8_t(m.Status)
	mem.soc = C.uint8_t(m.Soc)
	mem.current = C.int32_t(m.Current)
	mem.cycle = C.uint16_t(m.Cycle)
	cSlice_bq_ntc := mem.bq_ntc[:]
	humble.Int8ArrayToC(*(*[]humble.CInt8)(unsafe.Pointer(&cSlice_bq_ntc)), m.BqNtc[:])
	cSlice_mcu_ntc := mem.mcu_ntc[:]
	humble.Int8ArrayToC(*(*[]humble.CInt8)(unsafe.Pointer(&cSlice_mcu_ntc)), m.McuNtc[:])
	cSlice_cell_vol := mem.cell_vol[:]
	humble.Uint16ArrayToC(*(*[]humble.CUint16)(unsafe.Pointer(&cSlice_cell_vol)), m.CellVol[:])
}

func (t _BmsStateTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*BmsState)
	mem := (*C.unitree_go__msg__BmsState)(ros2_message_buffer)
	m.VersionHigh = uint8(mem.version_high)
	m.VersionLow = uint8(mem.version_low)
	m.Status = uint8(mem.status)
	m.Soc = uint8(mem.soc)
	m.Current = int32(mem.current)
	m.Cycle = uint16(mem.cycle)
	cSlice_bq_ntc := mem.bq_ntc[:]
	humble.Int8ArrayToGo(m.BqNtc[:], *(*[]humble.CInt8)(unsafe.Pointer(&cSlice_bq_ntc)))
	cSlice_mcu_ntc := mem.mcu_ntc[:]
	humble.Int8ArrayToGo(m.McuNtc[:], *(*[]humble.CInt8)(unsafe.Pointer(&cSlice_mcu_ntc)))
	cSlice_cell_vol := mem.cell_vol[:]
	humble.Uint16ArrayToGo(m.CellVol[:], *(*[]humble.CUint16)(unsafe.Pointer(&cSlice_cell_vol)))
}

func (t _BmsStateTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__unitree_go__msg__BmsState())
}

type CBmsState = C.unitree_go__msg__BmsState
type CBmsStateSequence = C.unitree_go__msg__BmsState__Sequence

func BmsStateSequenceToGo(goSlice *[]BmsState, cSlice CBmsStateSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]BmsState, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		BmsStateTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func BmsStateSequenceToC(cSlice *CBmsStateSequence, goSlice []BmsState) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.unitree_go__msg__BmsState)(C.malloc(C.sizeof_struct_unitree_go__msg__BmsState * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		BmsStateTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func BmsStateArrayToGo(goSlice []BmsState, cSlice []CBmsState) {
	for i := 0; i < len(cSlice); i++ {
		BmsStateTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func BmsStateArrayToC(cSlice []CBmsState, goSlice []BmsState) {
	for i := 0; i < len(goSlice); i++ {
		BmsStateTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
