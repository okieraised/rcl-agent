// Code generated by ros2gen. DO NOT EDIT.

package nav_msgs_msg

import (
	"unsafe"

	geometry_msgs_msg "github.com/okieraised/monitoring-agent/internal/ros_msgs/geometry_msgs/msg"
	std_msgs_msg "github.com/okieraised/monitoring-agent/internal/ros_msgs/std_msgs/msg"
	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <nav_msgs/msg/goals.h>

*/
import "C"

func init() {
	humble.RegisterMessage("nav_msgs/Goals", GoalsTypeSupport)
	humble.RegisterMessage("nav_msgs/msg/Goals", GoalsTypeSupport)
}

type Goals struct {
	Header std_msgs_msg.Header             `yaml:"header"` // This header will store the time at which the poses were computed (not to be confused with the stamps of the poses themselves)In the case that individual poses do not have their frame_id set or their timetamp set they will use the default value here.
	Goals  []geometry_msgs_msg.PoseStamped `yaml:"goals"`  // An array of goals to for navigation to achieve.The goals should be executed in the order of the array.The header and stamp are intended to be used for computing the position of the goals.They may vary to support cases of goals that are moving with respect to the robot.
}

// NewGoals creates a new Goals with default values.
func NewGoals() *Goals {
	self := Goals{}
	self.SetDefaults()
	return &self
}

func (t *Goals) Clone() *Goals {
	c := &Goals{}
	c.Header = *t.Header.Clone()
	if t.Goals != nil {
		c.Goals = make([]geometry_msgs_msg.PoseStamped, len(t.Goals))
		geometry_msgs_msg.ClonePoseStampedSlice(c.Goals, t.Goals)
	}
	return c
}

func (t *Goals) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *Goals) SetDefaults() {
	t.Header.SetDefaults()
	t.Goals = nil
}

func (t *Goals) GetTypeSupport() humble.MessageTypeSupport {
	return GoalsTypeSupport
}

// GoalsPublisher wraps humble.Publisher to provide type safe helper
// functions
type GoalsPublisher struct {
	*humble.Publisher
}

// NewGoalsPublisher creates and returns a new publisher for the
// Goals
func NewGoalsPublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*GoalsPublisher, error) {
	pub, err := node.NewPublisher(topicName, GoalsTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &GoalsPublisher{pub}, nil
}

func (p *GoalsPublisher) Publish(msg *Goals) error {
	return p.Publisher.Publish(msg)
}

// GoalsSubscription wraps humble.Subscription to provide type safe helper
// functions
type GoalsSubscription struct {
	*humble.Subscription
}

// GoalsSubscriptionCallback type is used to provide a subscription
// handler function for a GoalsSubscription.
type GoalsSubscriptionCallback func(msg *Goals, info *humble.MessageInfo, err error)

// NewGoalsSubscription creates and returns a new subscription for the
// Goals
func NewGoalsSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback GoalsSubscriptionCallback) (*GoalsSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg Goals
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, GoalsTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &GoalsSubscription{sub}, nil
}

func (s *GoalsSubscription) TakeMessage(out *Goals) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneGoalsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneGoalsSlice(dst, src []Goals) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var GoalsTypeSupport humble.MessageTypeSupport = _GoalsTypeSupport{}

type _GoalsTypeSupport struct{}

func (t _GoalsTypeSupport) New() humble.Message {
	return NewGoals()
}

func (t _GoalsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.nav_msgs__msg__Goals
	return (unsafe.Pointer)(C.nav_msgs__msg__Goals__create())
}

func (t _GoalsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.nav_msgs__msg__Goals__destroy((*C.nav_msgs__msg__Goals)(pointer_to_free))
}

func (t _GoalsTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*Goals)
	mem := (*C.nav_msgs__msg__Goals)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	geometry_msgs_msg.PoseStampedSequenceToC((*geometry_msgs_msg.CPoseStampedSequence)(unsafe.Pointer(&mem.goals)), m.Goals)
}

func (t _GoalsTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*Goals)
	mem := (*C.nav_msgs__msg__Goals)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	geometry_msgs_msg.PoseStampedSequenceToGo(&m.Goals, *(*geometry_msgs_msg.CPoseStampedSequence)(unsafe.Pointer(&mem.goals)))
}

func (t _GoalsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__nav_msgs__msg__Goals())
}

type CGoals = C.nav_msgs__msg__Goals
type CGoalsSequence = C.nav_msgs__msg__Goals__Sequence

func GoalsSequenceToGo(goSlice *[]Goals, cSlice CGoalsSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]Goals, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		GoalsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func GoalsSequenceToC(cSlice *CGoalsSequence, goSlice []Goals) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.nav_msgs__msg__Goals)(C.malloc(C.sizeof_struct_nav_msgs__msg__Goals * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		GoalsTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func GoalsArrayToGo(goSlice []Goals, cSlice []CGoals) {
	for i := 0; i < len(cSlice); i++ {
		GoalsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func GoalsArrayToC(cSlice []CGoals, goSlice []Goals) {
	for i := 0; i < len(goSlice); i++ {
		GoalsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
