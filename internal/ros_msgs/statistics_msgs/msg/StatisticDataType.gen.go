// Code generated by ros2gen. DO NOT EDIT.

package statistics_msgs_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <statistics_msgs/msg/statistic_data_type.h>

*/
import "C"

func init() {
	humble.RegisterMessage("statistics_msgs/StatisticDataType", StatisticDataTypeTypeSupport)
	humble.RegisterMessage("statistics_msgs/msg/StatisticDataType", StatisticDataTypeTypeSupport)
}

const (
	StatisticDataType_STATISTICS_DATA_TYPE_UNINITIALIZED uint8 = 0 // Constant for uninitialized
	StatisticDataType_STATISTICS_DATA_TYPE_AVERAGE       uint8 = 1 // Allowed values
	StatisticDataType_STATISTICS_DATA_TYPE_MINIMUM       uint8 = 2
	StatisticDataType_STATISTICS_DATA_TYPE_MAXIMUM       uint8 = 3
	StatisticDataType_STATISTICS_DATA_TYPE_STDDEV        uint8 = 4
	StatisticDataType_STATISTICS_DATA_TYPE_SAMPLE_COUNT  uint8 = 5
)

type StatisticDataType struct {
}

// NewStatisticDataType creates a new StatisticDataType with default values.
func NewStatisticDataType() *StatisticDataType {
	self := StatisticDataType{}
	self.SetDefaults()
	return &self
}

func (t *StatisticDataType) Clone() *StatisticDataType {
	c := &StatisticDataType{}
	return c
}

func (t *StatisticDataType) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *StatisticDataType) SetDefaults() {
}

func (t *StatisticDataType) GetTypeSupport() humble.MessageTypeSupport {
	return StatisticDataTypeTypeSupport
}

// StatisticDataTypePublisher wraps humble.Publisher to provide type safe helper
// functions
type StatisticDataTypePublisher struct {
	*humble.Publisher
}

// NewStatisticDataTypePublisher creates and returns a new publisher for the
// StatisticDataType
func NewStatisticDataTypePublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*StatisticDataTypePublisher, error) {
	pub, err := node.NewPublisher(topicName, StatisticDataTypeTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &StatisticDataTypePublisher{pub}, nil
}

func (p *StatisticDataTypePublisher) Publish(msg *StatisticDataType) error {
	return p.Publisher.Publish(msg)
}

// StatisticDataTypeSubscription wraps humble.Subscription to provide type safe helper
// functions
type StatisticDataTypeSubscription struct {
	*humble.Subscription
}

// StatisticDataTypeSubscriptionCallback type is used to provide a subscription
// handler function for a StatisticDataTypeSubscription.
type StatisticDataTypeSubscriptionCallback func(msg *StatisticDataType, info *humble.MessageInfo, err error)

// NewStatisticDataTypeSubscription creates and returns a new subscription for the
// StatisticDataType
func NewStatisticDataTypeSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback StatisticDataTypeSubscriptionCallback) (*StatisticDataTypeSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg StatisticDataType
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, StatisticDataTypeTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &StatisticDataTypeSubscription{sub}, nil
}

func (s *StatisticDataTypeSubscription) TakeMessage(out *StatisticDataType) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneStatisticDataTypeSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneStatisticDataTypeSlice(dst, src []StatisticDataType) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var StatisticDataTypeTypeSupport humble.MessageTypeSupport = _StatisticDataTypeTypeSupport{}

type _StatisticDataTypeTypeSupport struct{}

func (t _StatisticDataTypeTypeSupport) New() humble.Message {
	return NewStatisticDataType()
}

func (t _StatisticDataTypeTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.statistics_msgs__msg__StatisticDataType
	return (unsafe.Pointer)(C.statistics_msgs__msg__StatisticDataType__create())
}

func (t _StatisticDataTypeTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.statistics_msgs__msg__StatisticDataType__destroy((*C.statistics_msgs__msg__StatisticDataType)(pointer_to_free))
}

func (t _StatisticDataTypeTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {

}

func (t _StatisticDataTypeTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {

}

func (t _StatisticDataTypeTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__statistics_msgs__msg__StatisticDataType())
}

type CStatisticDataType = C.statistics_msgs__msg__StatisticDataType
type CStatisticDataTypeSequence = C.statistics_msgs__msg__StatisticDataType__Sequence

func StatisticDataTypeSequenceToGo(goSlice *[]StatisticDataType, cSlice CStatisticDataTypeSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]StatisticDataType, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		StatisticDataTypeTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func StatisticDataTypeSequenceToC(cSlice *CStatisticDataTypeSequence, goSlice []StatisticDataType) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.statistics_msgs__msg__StatisticDataType)(C.malloc(C.sizeof_struct_statistics_msgs__msg__StatisticDataType * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		StatisticDataTypeTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func StatisticDataTypeArrayToGo(goSlice []StatisticDataType, cSlice []CStatisticDataType) {
	for i := 0; i < len(cSlice); i++ {
		StatisticDataTypeTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func StatisticDataTypeArrayToC(cSlice []CStatisticDataType, goSlice []StatisticDataType) {
	for i := 0; i < len(goSlice); i++ {
		StatisticDataTypeTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
