// Code generated by ros2gen. DO NOT EDIT.

package realsense2_camera_msgs_action

/*
#include <rosidl_runtime_c/message_type_support_struct.h>
#include <realsense2_camera_msgs/action/triggered_calibration.h>
*/
import "C"

import (
	"context"
	"time"
	"unsafe"

	"github.com/okieraised/rclgo/humble"

	action_msgs_msg "github.com/okieraised/monitoring-agent/internal/ros_msgs/action_msgs/msg"
	action_msgs_srv "github.com/okieraised/monitoring-agent/internal/ros_msgs/action_msgs/srv"
)

func init() {
	humble.RegisterAction("realsense2_camera_msgs/TriggeredCalibration", TriggeredCalibrationTypeSupport)
	humble.RegisterAction("realsense2_camera_msgs/action/TriggeredCalibration", TriggeredCalibrationTypeSupport)
}

type _TriggeredCalibrationTypeSupport struct {}

func (s _TriggeredCalibrationTypeSupport) Goal() humble.MessageTypeSupport {
	return TriggeredCalibration_GoalTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) SendGoal() humble.ServiceTypeSupport {
	return TriggeredCalibration_SendGoalTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) NewSendGoalResponse(accepted bool, stamp time.Duration) humble.Message {
	msg := NewTriggeredCalibration_SendGoal_Response()
	msg.Accepted = accepted
	secs := stamp.Truncate(time.Second)
	msg.Stamp.Sec = int32(secs)
	msg.Stamp.Nanosec = uint32(stamp - secs)
	return msg
}

func (s _TriggeredCalibrationTypeSupport) Result() humble.MessageTypeSupport {
	return TriggeredCalibration_ResultTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) GetResult() humble.ServiceTypeSupport {
	return TriggeredCalibration_GetResultTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) NewGetResultResponse(status int8, result humble.Message) humble.Message {
	msg := NewTriggeredCalibration_GetResult_Response()
	msg.Status = status
	if result == nil {
		msg.Result = *NewTriggeredCalibration_Result()
	} else {
		msg.Result = *result.(*TriggeredCalibration_Result)
	}
	return msg
}

func (s _TriggeredCalibrationTypeSupport) CancelGoal() humble.ServiceTypeSupport {
	return action_msgs_srv.CancelGoalTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) Feedback() humble.MessageTypeSupport {
	return TriggeredCalibration_FeedbackTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) FeedbackMessage() humble.MessageTypeSupport {
	return TriggeredCalibration_FeedbackMessageTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) NewFeedbackMessage(goalID *humble.GoalID, feedback humble.Message) humble.Message {
	msg := NewTriggeredCalibration_FeedbackMessage()
	msg.GoalID.Uuid = *goalID
	msg.Feedback = *feedback.(*TriggeredCalibration_Feedback)
	return msg
}

func (s _TriggeredCalibrationTypeSupport) GoalStatusArray() humble.MessageTypeSupport {
	return action_msgs_msg.GoalStatusArrayTypeSupport
}

func (s _TriggeredCalibrationTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_action_type_support_handle__realsense2_camera_msgs__action__TriggeredCalibration())
}

// Modifying this variable is undefined behavior.
var TriggeredCalibrationTypeSupport humble.ActionTypeSupport = _TriggeredCalibrationTypeSupport{}

type TriggeredCalibrationFeedbackSender struct {
	sender humble.FeedbackSender
}

func (s *TriggeredCalibrationFeedbackSender) Send(msg *TriggeredCalibration_Feedback) error {
	return s.sender.Send(msg)
}

type TriggeredCalibrationGoalHandle struct{
	*humble.GoalHandle

	Description *TriggeredCalibration_Goal
}

func (g *TriggeredCalibrationGoalHandle) Accept() (*TriggeredCalibrationFeedbackSender, error) {
	s, err := g.GoalHandle.Accept()
	if err != nil {
		return nil, err
	}
	return &TriggeredCalibrationFeedbackSender{*s}, nil
}

type TriggeredCalibrationAction interface {
	ExecuteGoal(context.Context, *TriggeredCalibrationGoalHandle) (*TriggeredCalibration_Result, error)
}

func NewTriggeredCalibrationAction(
	executeGoal func(context.Context, *TriggeredCalibrationGoalHandle) (*TriggeredCalibration_Result, error),
) TriggeredCalibrationAction {
	return _TriggeredCalibrationFuncAction(executeGoal)
}

type _TriggeredCalibrationFuncAction func(context.Context, *TriggeredCalibrationGoalHandle) (*TriggeredCalibration_Result, error)

func (a _TriggeredCalibrationFuncAction) ExecuteGoal(
	ctx context.Context, goal *TriggeredCalibrationGoalHandle,
) (*TriggeredCalibration_Result, error) {
	return a(ctx, goal)
}

type _TriggeredCalibrationAction struct {
	action TriggeredCalibrationAction
}

func (a _TriggeredCalibrationAction) ExecuteGoal(ctx context.Context, handle *humble.GoalHandle) (humble.Message, error) {
	return a.action.ExecuteGoal(ctx, &TriggeredCalibrationGoalHandle{
		GoalHandle:  handle,
		Description: handle.Description.(*TriggeredCalibration_Goal),
	})
}

func (a _TriggeredCalibrationAction) TypeSupport() humble.ActionTypeSupport {
	return TriggeredCalibrationTypeSupport
}

type TriggeredCalibrationServer struct{
	*humble.ActionServer
}

func NewTriggeredCalibrationServer(node *humble.Node, name string, action TriggeredCalibrationAction, opts *humble.ActionServerOptions) (*TriggeredCalibrationServer, error) {
	server, err := node.NewActionServer(name, _TriggeredCalibrationAction{action}, opts)
	if err != nil {
		return nil, err
	}
	return &TriggeredCalibrationServer{server}, nil
}

type TriggeredCalibrationFeedbackHandler func(context.Context, *TriggeredCalibration_FeedbackMessage)

type TriggeredCalibrationStatusHandler func(context.Context, *action_msgs_msg.GoalStatus)

type TriggeredCalibrationClient struct{
	*humble.ActionClient
}

func NewTriggeredCalibrationClient(node *humble.Node, name string, opts *humble.ActionClientOptions) (*TriggeredCalibrationClient, error) {
	client, err := node.NewActionClient(name, TriggeredCalibrationTypeSupport, opts)
	if err != nil {
		return nil, err
	}
	return &TriggeredCalibrationClient{client}, nil
}

func (c *TriggeredCalibrationClient) WatchGoal(ctx context.Context, goal *TriggeredCalibration_Goal, onFeedback TriggeredCalibrationFeedbackHandler) (*TriggeredCalibration_GetResult_Response, *humble.GoalID, error) {
	var resp humble.Message
	var goalID *humble.GoalID
	var err error
	if onFeedback == nil {
		resp, goalID, err = c.ActionClient.WatchGoal(ctx, goal, nil)
	} else {
		resp, goalID, err = c.ActionClient.WatchGoal(ctx, goal, func(ctx context.Context, msg humble.Message) {
			onFeedback(ctx, msg.(*TriggeredCalibration_FeedbackMessage))
		})
	}
	if r, ok := resp.(*TriggeredCalibration_GetResult_Response); ok {
		return r, goalID, err
	}
	return nil, goalID, err
}

func (c *TriggeredCalibrationClient) SendGoal(ctx context.Context, goal *TriggeredCalibration_Goal) (*TriggeredCalibration_SendGoal_Response, *humble.GoalID, error) {
	resp, id, err := c.ActionClient.SendGoal(ctx, goal)
	if r, ok := resp.(*TriggeredCalibration_SendGoal_Response); ok {
		return r, id, err
	}
	return nil, id, err
}

func (c *TriggeredCalibrationClient) SendGoalRequest(ctx context.Context, request *TriggeredCalibration_SendGoal_Request) (*TriggeredCalibration_SendGoal_Response, error) {
	resp, err := c.ActionClient.SendGoalRequest(ctx, request)
	if r, ok := resp.(*TriggeredCalibration_SendGoal_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *TriggeredCalibrationClient) GetResult(ctx context.Context, goalID *humble.GoalID) (*TriggeredCalibration_GetResult_Response, error) {
	resp, err := c.ActionClient.GetResult(ctx, goalID)
	if r, ok := resp.(*TriggeredCalibration_GetResult_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *TriggeredCalibrationClient) CancelGoal(ctx context.Context, request *action_msgs_srv.CancelGoal_Request) (*action_msgs_srv.CancelGoal_Response, error) {
	resp, err := c.ActionClient.CancelGoal(ctx, request)
	if r, ok := resp.(*action_msgs_srv.CancelGoal_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *TriggeredCalibrationClient) WatchFeedback(ctx context.Context, goalID *humble.GoalID, handler TriggeredCalibrationFeedbackHandler) <-chan error {
	return c.ActionClient.WatchFeedback(ctx, goalID, func(ctx context.Context, msg humble.Message) {
		handler(ctx, msg.(*TriggeredCalibration_FeedbackMessage))
	})
}

func (c *TriggeredCalibrationClient) WatchStatus(ctx context.Context, goalID *humble.GoalID, handler TriggeredCalibrationStatusHandler) <-chan error {
	return c.ActionClient.WatchStatus(ctx, goalID, func(ctx context.Context, msg humble.Message) {
		handler(ctx, msg.(*action_msgs_msg.GoalStatus))
	})
}
