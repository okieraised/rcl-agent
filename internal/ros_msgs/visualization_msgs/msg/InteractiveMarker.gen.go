// Code generated by ros2gen. DO NOT EDIT.

package visualization_msgs_msg

import (
	"unsafe"

	geometry_msgs_msg "github.com/okieraised/monitoring-agent/internal/ros_msgs/geometry_msgs/msg"
	std_msgs_msg "github.com/okieraised/monitoring-agent/internal/ros_msgs/std_msgs/msg"
	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <visualization_msgs/msg/interactive_marker.h>

*/
import "C"

func init() {
	humble.RegisterMessage("visualization_msgs/InteractiveMarker", InteractiveMarkerTypeSupport)
	humble.RegisterMessage("visualization_msgs/msg/InteractiveMarker", InteractiveMarkerTypeSupport)
}

type InteractiveMarker struct {
	Header      std_msgs_msg.Header        `yaml:"header"`       // Time/frame info.If header.time is set to 0, the marker will be retransformed intoits frame on each timestep. You will receive the pose feedbackin the same frame.Otherwise, you might receive feedback in a different frame.For rviz, this will be the current 'fixed frame' set by the user.
	Pose        geometry_msgs_msg.Pose     `yaml:"pose"`         // Initial pose. Also, defines the pivot point for rotations.
	Name        string                     `yaml:"name"`         // Identifying string. Must be globally unique inthe topic that this message is sent through.
	Description string                     `yaml:"description"`  // Short description (< 40 characters).
	Scale       float32                    `yaml:"scale"`        // Scale to be used for default controls (default=1).
	MenuEntries []MenuEntry                `yaml:"menu_entries"` // All menu and submenu entries associated with this marker.
	Controls    []InteractiveMarkerControl `yaml:"controls"`     // List of controls displayed for this marker.
}

// NewInteractiveMarker creates a new InteractiveMarker with default values.
func NewInteractiveMarker() *InteractiveMarker {
	self := InteractiveMarker{}
	self.SetDefaults()
	return &self
}

func (t *InteractiveMarker) Clone() *InteractiveMarker {
	c := &InteractiveMarker{}
	c.Header = *t.Header.Clone()
	c.Pose = *t.Pose.Clone()
	c.Name = t.Name
	c.Description = t.Description
	c.Scale = t.Scale
	if t.MenuEntries != nil {
		c.MenuEntries = make([]MenuEntry, len(t.MenuEntries))
		CloneMenuEntrySlice(c.MenuEntries, t.MenuEntries)
	}
	if t.Controls != nil {
		c.Controls = make([]InteractiveMarkerControl, len(t.Controls))
		CloneInteractiveMarkerControlSlice(c.Controls, t.Controls)
	}
	return c
}

func (t *InteractiveMarker) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *InteractiveMarker) SetDefaults() {
	t.Header.SetDefaults()
	t.Pose.SetDefaults()
	t.Name = ""
	t.Description = ""
	t.Scale = 0
	t.MenuEntries = nil
	t.Controls = nil
}

func (t *InteractiveMarker) GetTypeSupport() humble.MessageTypeSupport {
	return InteractiveMarkerTypeSupport
}

// InteractiveMarkerPublisher wraps humble.Publisher to provide type safe helper
// functions
type InteractiveMarkerPublisher struct {
	*humble.Publisher
}

// NewInteractiveMarkerPublisher creates and returns a new publisher for the
// InteractiveMarker
func NewInteractiveMarkerPublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*InteractiveMarkerPublisher, error) {
	pub, err := node.NewPublisher(topicName, InteractiveMarkerTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &InteractiveMarkerPublisher{pub}, nil
}

func (p *InteractiveMarkerPublisher) Publish(msg *InteractiveMarker) error {
	return p.Publisher.Publish(msg)
}

// InteractiveMarkerSubscription wraps humble.Subscription to provide type safe helper
// functions
type InteractiveMarkerSubscription struct {
	*humble.Subscription
}

// InteractiveMarkerSubscriptionCallback type is used to provide a subscription
// handler function for a InteractiveMarkerSubscription.
type InteractiveMarkerSubscriptionCallback func(msg *InteractiveMarker, info *humble.MessageInfo, err error)

// NewInteractiveMarkerSubscription creates and returns a new subscription for the
// InteractiveMarker
func NewInteractiveMarkerSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback InteractiveMarkerSubscriptionCallback) (*InteractiveMarkerSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg InteractiveMarker
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, InteractiveMarkerTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &InteractiveMarkerSubscription{sub}, nil
}

func (s *InteractiveMarkerSubscription) TakeMessage(out *InteractiveMarker) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneInteractiveMarkerSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneInteractiveMarkerSlice(dst, src []InteractiveMarker) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var InteractiveMarkerTypeSupport humble.MessageTypeSupport = _InteractiveMarkerTypeSupport{}

type _InteractiveMarkerTypeSupport struct{}

func (t _InteractiveMarkerTypeSupport) New() humble.Message {
	return NewInteractiveMarker()
}

func (t _InteractiveMarkerTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.visualization_msgs__msg__InteractiveMarker
	return (unsafe.Pointer)(C.visualization_msgs__msg__InteractiveMarker__create())
}

func (t _InteractiveMarkerTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.visualization_msgs__msg__InteractiveMarker__destroy((*C.visualization_msgs__msg__InteractiveMarker)(pointer_to_free))
}

func (t _InteractiveMarkerTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*InteractiveMarker)
	mem := (*C.visualization_msgs__msg__InteractiveMarker)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	geometry_msgs_msg.PoseTypeSupport.AsCStruct(unsafe.Pointer(&mem.pose), &m.Pose)
	humble.StringAsCStruct(unsafe.Pointer(&mem.name), m.Name)
	humble.StringAsCStruct(unsafe.Pointer(&mem.description), m.Description)
	mem.scale = C.float(m.Scale)
	MenuEntrySequenceToC(&mem.menu_entries, m.MenuEntries)
	InteractiveMarkerControlSequenceToC(&mem.controls, m.Controls)
}

func (t _InteractiveMarkerTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*InteractiveMarker)
	mem := (*C.visualization_msgs__msg__InteractiveMarker)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	geometry_msgs_msg.PoseTypeSupport.AsGoStruct(&m.Pose, unsafe.Pointer(&mem.pose))
	humble.StringAsGoStruct(&m.Name, unsafe.Pointer(&mem.name))
	humble.StringAsGoStruct(&m.Description, unsafe.Pointer(&mem.description))
	m.Scale = float32(mem.scale)
	MenuEntrySequenceToGo(&m.MenuEntries, mem.menu_entries)
	InteractiveMarkerControlSequenceToGo(&m.Controls, mem.controls)
}

func (t _InteractiveMarkerTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__visualization_msgs__msg__InteractiveMarker())
}

type CInteractiveMarker = C.visualization_msgs__msg__InteractiveMarker
type CInteractiveMarkerSequence = C.visualization_msgs__msg__InteractiveMarker__Sequence

func InteractiveMarkerSequenceToGo(goSlice *[]InteractiveMarker, cSlice CInteractiveMarkerSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]InteractiveMarker, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		InteractiveMarkerTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func InteractiveMarkerSequenceToC(cSlice *CInteractiveMarkerSequence, goSlice []InteractiveMarker) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.visualization_msgs__msg__InteractiveMarker)(C.malloc(C.sizeof_struct_visualization_msgs__msg__InteractiveMarker * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		InteractiveMarkerTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func InteractiveMarkerArrayToGo(goSlice []InteractiveMarker, cSlice []CInteractiveMarker) {
	for i := 0; i < len(cSlice); i++ {
		InteractiveMarkerTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func InteractiveMarkerArrayToC(cSlice []CInteractiveMarker, goSlice []InteractiveMarker) {
	for i := 0; i < len(goSlice); i++ {
		InteractiveMarkerTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
