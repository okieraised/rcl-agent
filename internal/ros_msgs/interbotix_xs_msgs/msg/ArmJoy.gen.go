// Code generated by ros2gen. DO NOT EDIT.

package interbotix_xs_msgs_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <interbotix_xs_msgs/msg/arm_joy.h>

*/
import "C"

func init() {
	humble.RegisterMessage("interbotix_xs_msgs/ArmJoy", ArmJoyTypeSupport)
	humble.RegisterMessage("interbotix_xs_msgs/msg/ArmJoy", ArmJoyTypeSupport)
}

const (
	ArmJoy_EE_X_INC        int8 = 1 // Control the motion of the virtual 'ee_gripper_link' or end effector using the modern_robotics_ik enginePosition Control
	ArmJoy_EE_X_DEC        int8 = 2
	ArmJoy_EE_Y_INC        int8 = 3
	ArmJoy_EE_Y_DEC        int8 = 4
	ArmJoy_EE_Z_INC        int8 = 5
	ArmJoy_EE_Z_DEC        int8 = 6
	ArmJoy_EE_ROLL_CCW     int8 = 7 // Orientation Control
	ArmJoy_EE_ROLL_CW      int8 = 8
	ArmJoy_EE_PITCH_UP     int8 = 9
	ArmJoy_EE_PITCH_DOWN   int8 = 10
	ArmJoy_WAIST_CCW       int8 = 11 // Control the motion of independent joints on the Arm or send predefined robot posesWaist Joint Control
	ArmJoy_WAIST_CW        int8 = 12
	ArmJoy_GRIPPER_RELEASE int8 = 13 // Gripper Control
	ArmJoy_GRIPPER_GRASP   int8 = 14
	ArmJoy_HOME_POSE       int8 = 15 // Pose Control
	ArmJoy_SLEEP_POSE      int8 = 16
	ArmJoy_SPEED_INC       int8 = 17 // Customize configurations for the Interbotix ArmInc/Dec Joint speed
	ArmJoy_SPEED_DEC       int8 = 18
	ArmJoy_SPEED_COARSE    int8 = 19 // Quickly toggle between a fast and slow speed setting
	ArmJoy_SPEED_FINE      int8 = 20
	ArmJoy_GRIPPER_PWM_INC int8 = 21 // Inc/Dec Gripper pressure
	ArmJoy_GRIPPER_PWM_DEC int8 = 22
	ArmJoy_TORQUE_ON       int8 = 23 // Torque On/Off all servos
	ArmJoy_TORQUE_OFF      int8 = 24
)

type ArmJoy struct {
	EeXCmd         int8 `yaml:"ee_x_cmd"` // Control the motion of the Interbotix Arm
	EeYCmd         int8 `yaml:"ee_y_cmd"`
	EeZCmd         int8 `yaml:"ee_z_cmd"`
	EeRollCmd      int8 `yaml:"ee_roll_cmd"`
	EePitchCmd     int8 `yaml:"ee_pitch_cmd"`
	WaistCmd       int8 `yaml:"waist_cmd"` // Independent Joint/Pose Control
	GripperCmd     int8 `yaml:"gripper_cmd"`
	PoseCmd        int8 `yaml:"pose_cmd"`
	SpeedCmd       int8 `yaml:"speed_cmd"` // Misc. Configs
	SpeedToggleCmd int8 `yaml:"speed_toggle_cmd"`
	GripperPwmCmd  int8 `yaml:"gripper_pwm_cmd"`
	TorqueCmd      int8 `yaml:"torque_cmd"`
}

// NewArmJoy creates a new ArmJoy with default values.
func NewArmJoy() *ArmJoy {
	self := ArmJoy{}
	self.SetDefaults()
	return &self
}

func (t *ArmJoy) Clone() *ArmJoy {
	c := &ArmJoy{}
	c.EeXCmd = t.EeXCmd
	c.EeYCmd = t.EeYCmd
	c.EeZCmd = t.EeZCmd
	c.EeRollCmd = t.EeRollCmd
	c.EePitchCmd = t.EePitchCmd
	c.WaistCmd = t.WaistCmd
	c.GripperCmd = t.GripperCmd
	c.PoseCmd = t.PoseCmd
	c.SpeedCmd = t.SpeedCmd
	c.SpeedToggleCmd = t.SpeedToggleCmd
	c.GripperPwmCmd = t.GripperPwmCmd
	c.TorqueCmd = t.TorqueCmd
	return c
}

func (t *ArmJoy) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *ArmJoy) SetDefaults() {
	t.EeXCmd = 0
	t.EeYCmd = 0
	t.EeZCmd = 0
	t.EeRollCmd = 0
	t.EePitchCmd = 0
	t.WaistCmd = 0
	t.GripperCmd = 0
	t.PoseCmd = 0
	t.SpeedCmd = 0
	t.SpeedToggleCmd = 0
	t.GripperPwmCmd = 0
	t.TorqueCmd = 0
}

func (t *ArmJoy) GetTypeSupport() humble.MessageTypeSupport {
	return ArmJoyTypeSupport
}

// ArmJoyPublisher wraps humble.Publisher to provide type safe helper
// functions
type ArmJoyPublisher struct {
	*humble.Publisher
}

// NewArmJoyPublisher creates and returns a new publisher for the
// ArmJoy
func NewArmJoyPublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*ArmJoyPublisher, error) {
	pub, err := node.NewPublisher(topicName, ArmJoyTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ArmJoyPublisher{pub}, nil
}

func (p *ArmJoyPublisher) Publish(msg *ArmJoy) error {
	return p.Publisher.Publish(msg)
}

// ArmJoySubscription wraps humble.Subscription to provide type safe helper
// functions
type ArmJoySubscription struct {
	*humble.Subscription
}

// ArmJoySubscriptionCallback type is used to provide a subscription
// handler function for a ArmJoySubscription.
type ArmJoySubscriptionCallback func(msg *ArmJoy, info *humble.MessageInfo, err error)

// NewArmJoySubscription creates and returns a new subscription for the
// ArmJoy
func NewArmJoySubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback ArmJoySubscriptionCallback) (*ArmJoySubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg ArmJoy
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, ArmJoyTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ArmJoySubscription{sub}, nil
}

func (s *ArmJoySubscription) TakeMessage(out *ArmJoy) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneArmJoySlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneArmJoySlice(dst, src []ArmJoy) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ArmJoyTypeSupport humble.MessageTypeSupport = _ArmJoyTypeSupport{}

type _ArmJoyTypeSupport struct{}

func (t _ArmJoyTypeSupport) New() humble.Message {
	return NewArmJoy()
}

func (t _ArmJoyTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.interbotix_xs_msgs__msg__ArmJoy
	return (unsafe.Pointer)(C.interbotix_xs_msgs__msg__ArmJoy__create())
}

func (t _ArmJoyTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.interbotix_xs_msgs__msg__ArmJoy__destroy((*C.interbotix_xs_msgs__msg__ArmJoy)(pointer_to_free))
}

func (t _ArmJoyTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*ArmJoy)
	mem := (*C.interbotix_xs_msgs__msg__ArmJoy)(dst)
	mem.ee_x_cmd = C.int8_t(m.EeXCmd)
	mem.ee_y_cmd = C.int8_t(m.EeYCmd)
	mem.ee_z_cmd = C.int8_t(m.EeZCmd)
	mem.ee_roll_cmd = C.int8_t(m.EeRollCmd)
	mem.ee_pitch_cmd = C.int8_t(m.EePitchCmd)
	mem.waist_cmd = C.int8_t(m.WaistCmd)
	mem.gripper_cmd = C.int8_t(m.GripperCmd)
	mem.pose_cmd = C.int8_t(m.PoseCmd)
	mem.speed_cmd = C.int8_t(m.SpeedCmd)
	mem.speed_toggle_cmd = C.int8_t(m.SpeedToggleCmd)
	mem.gripper_pwm_cmd = C.int8_t(m.GripperPwmCmd)
	mem.torque_cmd = C.int8_t(m.TorqueCmd)
}

func (t _ArmJoyTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*ArmJoy)
	mem := (*C.interbotix_xs_msgs__msg__ArmJoy)(ros2_message_buffer)
	m.EeXCmd = int8(mem.ee_x_cmd)
	m.EeYCmd = int8(mem.ee_y_cmd)
	m.EeZCmd = int8(mem.ee_z_cmd)
	m.EeRollCmd = int8(mem.ee_roll_cmd)
	m.EePitchCmd = int8(mem.ee_pitch_cmd)
	m.WaistCmd = int8(mem.waist_cmd)
	m.GripperCmd = int8(mem.gripper_cmd)
	m.PoseCmd = int8(mem.pose_cmd)
	m.SpeedCmd = int8(mem.speed_cmd)
	m.SpeedToggleCmd = int8(mem.speed_toggle_cmd)
	m.GripperPwmCmd = int8(mem.gripper_pwm_cmd)
	m.TorqueCmd = int8(mem.torque_cmd)
}

func (t _ArmJoyTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__interbotix_xs_msgs__msg__ArmJoy())
}

type CArmJoy = C.interbotix_xs_msgs__msg__ArmJoy
type CArmJoySequence = C.interbotix_xs_msgs__msg__ArmJoy__Sequence

func ArmJoySequenceToGo(goSlice *[]ArmJoy, cSlice CArmJoySequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]ArmJoy, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ArmJoyTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func ArmJoySequenceToC(cSlice *CArmJoySequence, goSlice []ArmJoy) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.interbotix_xs_msgs__msg__ArmJoy)(C.malloc(C.sizeof_struct_interbotix_xs_msgs__msg__ArmJoy * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ArmJoyTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func ArmJoyArrayToGo(goSlice []ArmJoy, cSlice []CArmJoy) {
	for i := 0; i < len(cSlice); i++ {
		ArmJoyTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func ArmJoyArrayToC(cSlice []CArmJoy, goSlice []ArmJoy) {
	for i := 0; i < len(goSlice); i++ {
		ArmJoyTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
