// Code generated by ros2gen. DO NOT EDIT.

package interbotix_xs_msgs_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <interbotix_xs_msgs/msg/hex_joy.h>

*/
import "C"

func init() {
	humble.RegisterMessage("interbotix_xs_msgs/HexJoy", HexJoyTypeSupport)
	humble.RegisterMessage("interbotix_xs_msgs/msg/HexJoy", HexJoyTypeSupport)
}

const (
	HexJoy_WORLD_X_INC      int8 = 1 // Command Options to move the Hexapod in the 'world' or in 'place'World Control
	HexJoy_WORLD_X_DEC      int8 = 2
	HexJoy_WORLD_Y_INC      int8 = 3
	HexJoy_WORLD_Y_DEC      int8 = 4
	HexJoy_WORLD_YAW_CCW    int8 = 5
	HexJoy_WORLD_YAW_CW     int8 = 6
	HexJoy_PLACE_X_INC      int8 = 7 // In Place Control
	HexJoy_PLACE_X_DEC      int8 = 8
	HexJoy_PLACE_Y_INC      int8 = 9
	HexJoy_PLACE_Y_DEC      int8 = 10
	HexJoy_PLACE_Z_INC      int8 = 11
	HexJoy_PLACE_Z_DEC      int8 = 12
	HexJoy_PLACE_ROLL_CCW   int8 = 13
	HexJoy_PLACE_ROLL_CW    int8 = 14
	HexJoy_PLACE_PITCH_UP   int8 = 15
	HexJoy_PLACE_PITCH_DOWN int8 = 16
	HexJoy_MOVE_HEXAPOD     int8 = 17 // Move Type
	HexJoy_MOVE_LEG         int8 = 18
	HexJoy_HOME_POSE        int8 = 19 // Pose Control
	HexJoy_SLEEP_POSE       int8 = 20
	HexJoy_GAIT_NEXT        int8 = 21 // Cycle through the various gaits when in 'move_hexapod' mode
	HexJoy_GAIT_PREVIOUS    int8 = 22
	HexJoy_LEG_NEXT         int8 = 23 // Cycle through the legs when in 'move_leg' mode
	HexJoy_LEG_PREVIOUS     int8 = 24
	HexJoy_WIDEN_STANCE     int8 = 25 // Widen or narrow the hexapod's stance
	HexJoy_NARROW_STANCE    int8 = 26
	HexJoy_REBOOT_MOTORS    int8 = 27 // Reboot motors if necessary
	HexJoy_SET_HOME_POSE    int8 = 28 // Set the current stance and hexapod height to be the new 'Home Pose'
	HexJoy_SPEED_INC        int8 = 29 // Inc/Dec speed
	HexJoy_SPEED_DEC        int8 = 30
	HexJoy_SPEED_COARSE     int8 = 31 // Quickly toggle between a fast and slow speed setting
	HexJoy_SPEED_FINE       int8 = 32
)

type HexJoy struct {
	WorldXCmd      int8 `yaml:"world_x_cmd"` // Control the motion of the Interbotix Hexapod
	WorldYCmd      int8 `yaml:"world_y_cmd"`
	WorldYawCmd    int8 `yaml:"world_yaw_cmd"`
	PlaceXCmd      int8 `yaml:"place_x_cmd"`
	PlaceYCmd      int8 `yaml:"place_y_cmd"`
	PlaceZCmd      int8 `yaml:"place_z_cmd"`
	PlaceRollCmd   int8 `yaml:"place_roll_cmd"`
	PlacePitchCmd  int8 `yaml:"place_pitch_cmd"`
	PoseCmd        int8 `yaml:"pose_cmd"`
	MoveTypeCmd    int8 `yaml:"move_type_cmd"`
	GaitToggleCmd  int8 `yaml:"gait_toggle_cmd"` // Other Options
	LegToggleCmd   int8 `yaml:"leg_toggle_cmd"`
	StanceCmd      int8 `yaml:"stance_cmd"`
	RebootCmd      int8 `yaml:"reboot_cmd"`
	SetHomePoseCmd int8 `yaml:"set_home_pose_cmd"`
	SpeedCmd       int8 `yaml:"speed_cmd"` // Speed Configs
	SpeedToggleCmd int8 `yaml:"speed_toggle_cmd"`
}

// NewHexJoy creates a new HexJoy with default values.
func NewHexJoy() *HexJoy {
	self := HexJoy{}
	self.SetDefaults()
	return &self
}

func (t *HexJoy) Clone() *HexJoy {
	c := &HexJoy{}
	c.WorldXCmd = t.WorldXCmd
	c.WorldYCmd = t.WorldYCmd
	c.WorldYawCmd = t.WorldYawCmd
	c.PlaceXCmd = t.PlaceXCmd
	c.PlaceYCmd = t.PlaceYCmd
	c.PlaceZCmd = t.PlaceZCmd
	c.PlaceRollCmd = t.PlaceRollCmd
	c.PlacePitchCmd = t.PlacePitchCmd
	c.PoseCmd = t.PoseCmd
	c.MoveTypeCmd = t.MoveTypeCmd
	c.GaitToggleCmd = t.GaitToggleCmd
	c.LegToggleCmd = t.LegToggleCmd
	c.StanceCmd = t.StanceCmd
	c.RebootCmd = t.RebootCmd
	c.SetHomePoseCmd = t.SetHomePoseCmd
	c.SpeedCmd = t.SpeedCmd
	c.SpeedToggleCmd = t.SpeedToggleCmd
	return c
}

func (t *HexJoy) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *HexJoy) SetDefaults() {
	t.WorldXCmd = 0
	t.WorldYCmd = 0
	t.WorldYawCmd = 0
	t.PlaceXCmd = 0
	t.PlaceYCmd = 0
	t.PlaceZCmd = 0
	t.PlaceRollCmd = 0
	t.PlacePitchCmd = 0
	t.PoseCmd = 0
	t.MoveTypeCmd = 0
	t.GaitToggleCmd = 0
	t.LegToggleCmd = 0
	t.StanceCmd = 0
	t.RebootCmd = 0
	t.SetHomePoseCmd = 0
	t.SpeedCmd = 0
	t.SpeedToggleCmd = 0
}

func (t *HexJoy) GetTypeSupport() humble.MessageTypeSupport {
	return HexJoyTypeSupport
}

// HexJoyPublisher wraps humble.Publisher to provide type safe helper
// functions
type HexJoyPublisher struct {
	*humble.Publisher
}

// NewHexJoyPublisher creates and returns a new publisher for the
// HexJoy
func NewHexJoyPublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*HexJoyPublisher, error) {
	pub, err := node.NewPublisher(topicName, HexJoyTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &HexJoyPublisher{pub}, nil
}

func (p *HexJoyPublisher) Publish(msg *HexJoy) error {
	return p.Publisher.Publish(msg)
}

// HexJoySubscription wraps humble.Subscription to provide type safe helper
// functions
type HexJoySubscription struct {
	*humble.Subscription
}

// HexJoySubscriptionCallback type is used to provide a subscription
// handler function for a HexJoySubscription.
type HexJoySubscriptionCallback func(msg *HexJoy, info *humble.MessageInfo, err error)

// NewHexJoySubscription creates and returns a new subscription for the
// HexJoy
func NewHexJoySubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback HexJoySubscriptionCallback) (*HexJoySubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg HexJoy
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, HexJoyTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &HexJoySubscription{sub}, nil
}

func (s *HexJoySubscription) TakeMessage(out *HexJoy) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneHexJoySlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneHexJoySlice(dst, src []HexJoy) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var HexJoyTypeSupport humble.MessageTypeSupport = _HexJoyTypeSupport{}

type _HexJoyTypeSupport struct{}

func (t _HexJoyTypeSupport) New() humble.Message {
	return NewHexJoy()
}

func (t _HexJoyTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.interbotix_xs_msgs__msg__HexJoy
	return (unsafe.Pointer)(C.interbotix_xs_msgs__msg__HexJoy__create())
}

func (t _HexJoyTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.interbotix_xs_msgs__msg__HexJoy__destroy((*C.interbotix_xs_msgs__msg__HexJoy)(pointer_to_free))
}

func (t _HexJoyTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*HexJoy)
	mem := (*C.interbotix_xs_msgs__msg__HexJoy)(dst)
	mem.world_x_cmd = C.int8_t(m.WorldXCmd)
	mem.world_y_cmd = C.int8_t(m.WorldYCmd)
	mem.world_yaw_cmd = C.int8_t(m.WorldYawCmd)
	mem.place_x_cmd = C.int8_t(m.PlaceXCmd)
	mem.place_y_cmd = C.int8_t(m.PlaceYCmd)
	mem.place_z_cmd = C.int8_t(m.PlaceZCmd)
	mem.place_roll_cmd = C.int8_t(m.PlaceRollCmd)
	mem.place_pitch_cmd = C.int8_t(m.PlacePitchCmd)
	mem.pose_cmd = C.int8_t(m.PoseCmd)
	mem.move_type_cmd = C.int8_t(m.MoveTypeCmd)
	mem.gait_toggle_cmd = C.int8_t(m.GaitToggleCmd)
	mem.leg_toggle_cmd = C.int8_t(m.LegToggleCmd)
	mem.stance_cmd = C.int8_t(m.StanceCmd)
	mem.reboot_cmd = C.int8_t(m.RebootCmd)
	mem.set_home_pose_cmd = C.int8_t(m.SetHomePoseCmd)
	mem.speed_cmd = C.int8_t(m.SpeedCmd)
	mem.speed_toggle_cmd = C.int8_t(m.SpeedToggleCmd)
}

func (t _HexJoyTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*HexJoy)
	mem := (*C.interbotix_xs_msgs__msg__HexJoy)(ros2_message_buffer)
	m.WorldXCmd = int8(mem.world_x_cmd)
	m.WorldYCmd = int8(mem.world_y_cmd)
	m.WorldYawCmd = int8(mem.world_yaw_cmd)
	m.PlaceXCmd = int8(mem.place_x_cmd)
	m.PlaceYCmd = int8(mem.place_y_cmd)
	m.PlaceZCmd = int8(mem.place_z_cmd)
	m.PlaceRollCmd = int8(mem.place_roll_cmd)
	m.PlacePitchCmd = int8(mem.place_pitch_cmd)
	m.PoseCmd = int8(mem.pose_cmd)
	m.MoveTypeCmd = int8(mem.move_type_cmd)
	m.GaitToggleCmd = int8(mem.gait_toggle_cmd)
	m.LegToggleCmd = int8(mem.leg_toggle_cmd)
	m.StanceCmd = int8(mem.stance_cmd)
	m.RebootCmd = int8(mem.reboot_cmd)
	m.SetHomePoseCmd = int8(mem.set_home_pose_cmd)
	m.SpeedCmd = int8(mem.speed_cmd)
	m.SpeedToggleCmd = int8(mem.speed_toggle_cmd)
}

func (t _HexJoyTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__interbotix_xs_msgs__msg__HexJoy())
}

type CHexJoy = C.interbotix_xs_msgs__msg__HexJoy
type CHexJoySequence = C.interbotix_xs_msgs__msg__HexJoy__Sequence

func HexJoySequenceToGo(goSlice *[]HexJoy, cSlice CHexJoySequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]HexJoy, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		HexJoyTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func HexJoySequenceToC(cSlice *CHexJoySequence, goSlice []HexJoy) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.interbotix_xs_msgs__msg__HexJoy)(C.malloc(C.sizeof_struct_interbotix_xs_msgs__msg__HexJoy * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		HexJoyTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func HexJoyArrayToGo(goSlice []HexJoy, cSlice []CHexJoy) {
	for i := 0; i < len(cSlice); i++ {
		HexJoyTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func HexJoyArrayToC(cSlice []CHexJoy, goSlice []HexJoy) {
	for i := 0; i < len(goSlice); i++ {
		HexJoyTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
