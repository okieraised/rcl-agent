// Code generated by ros2gen. DO NOT EDIT.

package interbotix_xs_msgs_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <interbotix_xs_msgs/msg/locobot_joy.h>

*/
import "C"

func init() {
	humble.RegisterMessage("interbotix_xs_msgs/LocobotJoy", LocobotJoyTypeSupport)
	humble.RegisterMessage("interbotix_xs_msgs/msg/LocobotJoy", LocobotJoyTypeSupport)
}

const (
	LocobotJoy_RESET_ODOM      int8 = 1 // Reset base odometry
	LocobotJoy_PAN_CCW         int8 = 2 // Control the pan-and-tilt mechanism
	LocobotJoy_PAN_CW          int8 = 3
	LocobotJoy_TILT_UP         int8 = 4
	LocobotJoy_TILT_DOWN       int8 = 5
	LocobotJoy_PAN_TILT_HOME   int8 = 6
	LocobotJoy_EE_X_INC        int8 = 7 // Control the motion of the virtual 'ee_gripper_link' or end effector using the modern_robotics_ik enginePosition Control
	LocobotJoy_EE_X_DEC        int8 = 8
	LocobotJoy_EE_Y_INC        int8 = 9
	LocobotJoy_EE_Y_DEC        int8 = 10
	LocobotJoy_EE_Z_INC        int8 = 11
	LocobotJoy_EE_Z_DEC        int8 = 12
	LocobotJoy_EE_ROLL_CCW     int8 = 13 // Orientation Control
	LocobotJoy_EE_ROLL_CW      int8 = 14
	LocobotJoy_EE_PITCH_UP     int8 = 15
	LocobotJoy_EE_PITCH_DOWN   int8 = 16
	LocobotJoy_WAIST_CCW       int8 = 17 // Control the motion of independent joints on the Arm or send predefined robot posesWaist Joint Control
	LocobotJoy_WAIST_CW        int8 = 18
	LocobotJoy_GRIPPER_RELEASE int8 = 19 // Gripper Control
	LocobotJoy_GRIPPER_GRASP   int8 = 20
	LocobotJoy_HOME_POSE       int8 = 21 // Pose Control
	LocobotJoy_SLEEP_POSE      int8 = 22
	LocobotJoy_SPEED_INC       int8 = 23 // Customize configurations for the Interbotix ArmInc/Dec Joint speed
	LocobotJoy_SPEED_DEC       int8 = 24
	LocobotJoy_SPEED_COARSE    int8 = 25 // Quickly toggle between a fast and slow speed setting
	LocobotJoy_SPEED_FINE      int8 = 26
	LocobotJoy_GRIPPER_PWM_INC int8 = 27 // Inc/Dec Gripper pressure
	LocobotJoy_GRIPPER_PWM_DEC int8 = 28
)

type LocobotJoy struct {
	BaseXCmd         float64 `yaml:"base_x_cmd"` // Control the motion of the Kobuki base
	BaseThetaCmd     float64 `yaml:"base_theta_cmd"`
	BaseResetOdomCmd int8    `yaml:"base_reset_odom_cmd"`
	PanCmd           int8    `yaml:"pan_cmd"` // Control the motion of the camera pan-and-tilt mechanism
	TiltCmd          int8    `yaml:"tilt_cmd"`
	EeXCmd           int8    `yaml:"ee_x_cmd"` // Control the motion of the Interbotix Arm
	EeYCmd           int8    `yaml:"ee_y_cmd"`
	EeZCmd           int8    `yaml:"ee_z_cmd"`
	EeRollCmd        int8    `yaml:"ee_roll_cmd"`
	EePitchCmd       int8    `yaml:"ee_pitch_cmd"`
	WaistCmd         int8    `yaml:"waist_cmd"` // Independent Joint/Pose Control
	GripperCmd       int8    `yaml:"gripper_cmd"`
	PoseCmd          int8    `yaml:"pose_cmd"`
	SpeedCmd         int8    `yaml:"speed_cmd"` // Arm Configs
	SpeedToggleCmd   int8    `yaml:"speed_toggle_cmd"`
	GripperPwmCmd    int8    `yaml:"gripper_pwm_cmd"`
}

// NewLocobotJoy creates a new LocobotJoy with default values.
func NewLocobotJoy() *LocobotJoy {
	self := LocobotJoy{}
	self.SetDefaults()
	return &self
}

func (t *LocobotJoy) Clone() *LocobotJoy {
	c := &LocobotJoy{}
	c.BaseXCmd = t.BaseXCmd
	c.BaseThetaCmd = t.BaseThetaCmd
	c.BaseResetOdomCmd = t.BaseResetOdomCmd
	c.PanCmd = t.PanCmd
	c.TiltCmd = t.TiltCmd
	c.EeXCmd = t.EeXCmd
	c.EeYCmd = t.EeYCmd
	c.EeZCmd = t.EeZCmd
	c.EeRollCmd = t.EeRollCmd
	c.EePitchCmd = t.EePitchCmd
	c.WaistCmd = t.WaistCmd
	c.GripperCmd = t.GripperCmd
	c.PoseCmd = t.PoseCmd
	c.SpeedCmd = t.SpeedCmd
	c.SpeedToggleCmd = t.SpeedToggleCmd
	c.GripperPwmCmd = t.GripperPwmCmd
	return c
}

func (t *LocobotJoy) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *LocobotJoy) SetDefaults() {
	t.BaseXCmd = 0
	t.BaseThetaCmd = 0
	t.BaseResetOdomCmd = 0
	t.PanCmd = 0
	t.TiltCmd = 0
	t.EeXCmd = 0
	t.EeYCmd = 0
	t.EeZCmd = 0
	t.EeRollCmd = 0
	t.EePitchCmd = 0
	t.WaistCmd = 0
	t.GripperCmd = 0
	t.PoseCmd = 0
	t.SpeedCmd = 0
	t.SpeedToggleCmd = 0
	t.GripperPwmCmd = 0
}

func (t *LocobotJoy) GetTypeSupport() humble.MessageTypeSupport {
	return LocobotJoyTypeSupport
}

// LocobotJoyPublisher wraps humble.Publisher to provide type safe helper
// functions
type LocobotJoyPublisher struct {
	*humble.Publisher
}

// NewLocobotJoyPublisher creates and returns a new publisher for the
// LocobotJoy
func NewLocobotJoyPublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*LocobotJoyPublisher, error) {
	pub, err := node.NewPublisher(topicName, LocobotJoyTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &LocobotJoyPublisher{pub}, nil
}

func (p *LocobotJoyPublisher) Publish(msg *LocobotJoy) error {
	return p.Publisher.Publish(msg)
}

// LocobotJoySubscription wraps humble.Subscription to provide type safe helper
// functions
type LocobotJoySubscription struct {
	*humble.Subscription
}

// LocobotJoySubscriptionCallback type is used to provide a subscription
// handler function for a LocobotJoySubscription.
type LocobotJoySubscriptionCallback func(msg *LocobotJoy, info *humble.MessageInfo, err error)

// NewLocobotJoySubscription creates and returns a new subscription for the
// LocobotJoy
func NewLocobotJoySubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback LocobotJoySubscriptionCallback) (*LocobotJoySubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg LocobotJoy
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, LocobotJoyTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &LocobotJoySubscription{sub}, nil
}

func (s *LocobotJoySubscription) TakeMessage(out *LocobotJoy) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneLocobotJoySlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneLocobotJoySlice(dst, src []LocobotJoy) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var LocobotJoyTypeSupport humble.MessageTypeSupport = _LocobotJoyTypeSupport{}

type _LocobotJoyTypeSupport struct{}

func (t _LocobotJoyTypeSupport) New() humble.Message {
	return NewLocobotJoy()
}

func (t _LocobotJoyTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.interbotix_xs_msgs__msg__LocobotJoy
	return (unsafe.Pointer)(C.interbotix_xs_msgs__msg__LocobotJoy__create())
}

func (t _LocobotJoyTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.interbotix_xs_msgs__msg__LocobotJoy__destroy((*C.interbotix_xs_msgs__msg__LocobotJoy)(pointer_to_free))
}

func (t _LocobotJoyTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*LocobotJoy)
	mem := (*C.interbotix_xs_msgs__msg__LocobotJoy)(dst)
	mem.base_x_cmd = C.double(m.BaseXCmd)
	mem.base_theta_cmd = C.double(m.BaseThetaCmd)
	mem.base_reset_odom_cmd = C.int8_t(m.BaseResetOdomCmd)
	mem.pan_cmd = C.int8_t(m.PanCmd)
	mem.tilt_cmd = C.int8_t(m.TiltCmd)
	mem.ee_x_cmd = C.int8_t(m.EeXCmd)
	mem.ee_y_cmd = C.int8_t(m.EeYCmd)
	mem.ee_z_cmd = C.int8_t(m.EeZCmd)
	mem.ee_roll_cmd = C.int8_t(m.EeRollCmd)
	mem.ee_pitch_cmd = C.int8_t(m.EePitchCmd)
	mem.waist_cmd = C.int8_t(m.WaistCmd)
	mem.gripper_cmd = C.int8_t(m.GripperCmd)
	mem.pose_cmd = C.int8_t(m.PoseCmd)
	mem.speed_cmd = C.int8_t(m.SpeedCmd)
	mem.speed_toggle_cmd = C.int8_t(m.SpeedToggleCmd)
	mem.gripper_pwm_cmd = C.int8_t(m.GripperPwmCmd)
}

func (t _LocobotJoyTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*LocobotJoy)
	mem := (*C.interbotix_xs_msgs__msg__LocobotJoy)(ros2_message_buffer)
	m.BaseXCmd = float64(mem.base_x_cmd)
	m.BaseThetaCmd = float64(mem.base_theta_cmd)
	m.BaseResetOdomCmd = int8(mem.base_reset_odom_cmd)
	m.PanCmd = int8(mem.pan_cmd)
	m.TiltCmd = int8(mem.tilt_cmd)
	m.EeXCmd = int8(mem.ee_x_cmd)
	m.EeYCmd = int8(mem.ee_y_cmd)
	m.EeZCmd = int8(mem.ee_z_cmd)
	m.EeRollCmd = int8(mem.ee_roll_cmd)
	m.EePitchCmd = int8(mem.ee_pitch_cmd)
	m.WaistCmd = int8(mem.waist_cmd)
	m.GripperCmd = int8(mem.gripper_cmd)
	m.PoseCmd = int8(mem.pose_cmd)
	m.SpeedCmd = int8(mem.speed_cmd)
	m.SpeedToggleCmd = int8(mem.speed_toggle_cmd)
	m.GripperPwmCmd = int8(mem.gripper_pwm_cmd)
}

func (t _LocobotJoyTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__interbotix_xs_msgs__msg__LocobotJoy())
}

type CLocobotJoy = C.interbotix_xs_msgs__msg__LocobotJoy
type CLocobotJoySequence = C.interbotix_xs_msgs__msg__LocobotJoy__Sequence

func LocobotJoySequenceToGo(goSlice *[]LocobotJoy, cSlice CLocobotJoySequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]LocobotJoy, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		LocobotJoyTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func LocobotJoySequenceToC(cSlice *CLocobotJoySequence, goSlice []LocobotJoy) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.interbotix_xs_msgs__msg__LocobotJoy)(C.malloc(C.sizeof_struct_interbotix_xs_msgs__msg__LocobotJoy * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		LocobotJoyTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func LocobotJoyArrayToGo(goSlice []LocobotJoy, cSlice []CLocobotJoy) {
	for i := 0; i < len(cSlice); i++ {
		LocobotJoyTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func LocobotJoyArrayToC(cSlice []CLocobotJoy, goSlice []LocobotJoy) {
	for i := 0; i < len(goSlice); i++ {
		LocobotJoyTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
