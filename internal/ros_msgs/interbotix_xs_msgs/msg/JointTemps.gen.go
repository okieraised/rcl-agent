// Code generated by ros2gen. DO NOT EDIT.

package interbotix_xs_msgs_msg

import (
	"unsafe"

	"github.com/okieraised/rclgo/humble"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <interbotix_xs_msgs/msg/joint_temps.h>

*/
import "C"

func init() {
	humble.RegisterMessage("interbotix_xs_msgs/JointTemps", JointTempsTypeSupport)
	humble.RegisterMessage("interbotix_xs_msgs/msg/JointTemps", JointTempsTypeSupport)
}

type JointTemps struct {
	Names []string `yaml:"names"`
	Temps []int32  `yaml:"temps"`
}

// NewJointTemps creates a new JointTemps with default values.
func NewJointTemps() *JointTemps {
	self := JointTemps{}
	self.SetDefaults()
	return &self
}

func (t *JointTemps) Clone() *JointTemps {
	c := &JointTemps{}
	if t.Names != nil {
		c.Names = make([]string, len(t.Names))
		copy(c.Names, t.Names)
	}
	if t.Temps != nil {
		c.Temps = make([]int32, len(t.Temps))
		copy(c.Temps, t.Temps)
	}
	return c
}

func (t *JointTemps) CloneMsg() humble.Message {
	return t.Clone()
}

func (t *JointTemps) SetDefaults() {
	t.Names = nil
	t.Temps = nil
}

func (t *JointTemps) GetTypeSupport() humble.MessageTypeSupport {
	return JointTempsTypeSupport
}

// JointTempsPublisher wraps humble.Publisher to provide type safe helper
// functions
type JointTempsPublisher struct {
	*humble.Publisher
}

// NewJointTempsPublisher creates and returns a new publisher for the
// JointTemps
func NewJointTempsPublisher(node *humble.Node, topicName string, options *humble.PublisherOptions) (*JointTempsPublisher, error) {
	pub, err := node.NewPublisher(topicName, JointTempsTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &JointTempsPublisher{pub}, nil
}

func (p *JointTempsPublisher) Publish(msg *JointTemps) error {
	return p.Publisher.Publish(msg)
}

// JointTempsSubscription wraps humble.Subscription to provide type safe helper
// functions
type JointTempsSubscription struct {
	*humble.Subscription
}

// JointTempsSubscriptionCallback type is used to provide a subscription
// handler function for a JointTempsSubscription.
type JointTempsSubscriptionCallback func(msg *JointTemps, info *humble.MessageInfo, err error)

// NewJointTempsSubscription creates and returns a new subscription for the
// JointTemps
func NewJointTempsSubscription(node *humble.Node, topicName string, opts *humble.SubscriptionOptions, subscriptionCallback JointTempsSubscriptionCallback) (*JointTempsSubscription, error) {
	callback := func(s *humble.Subscription) {
		var msg JointTemps
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, JointTempsTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &JointTempsSubscription{sub}, nil
}

func (s *JointTempsSubscription) TakeMessage(out *JointTemps) (*humble.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneJointTempsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneJointTempsSlice(dst, src []JointTemps) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var JointTempsTypeSupport humble.MessageTypeSupport = _JointTempsTypeSupport{}

type _JointTempsTypeSupport struct{}

func (t _JointTempsTypeSupport) New() humble.Message {
	return NewJointTemps()
}

func (t _JointTempsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.interbotix_xs_msgs__msg__JointTemps
	return (unsafe.Pointer)(C.interbotix_xs_msgs__msg__JointTemps__create())
}

func (t _JointTempsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.interbotix_xs_msgs__msg__JointTemps__destroy((*C.interbotix_xs_msgs__msg__JointTemps)(pointer_to_free))
}

func (t _JointTempsTypeSupport) AsCStruct(dst unsafe.Pointer, msg humble.Message) {
	m := msg.(*JointTemps)
	mem := (*C.interbotix_xs_msgs__msg__JointTemps)(dst)
	humble.StringSequenceToC((*humble.CStringSequence)(unsafe.Pointer(&mem.names)), m.Names)
	humble.Int32SequenceToC((*humble.CInt32Sequence)(unsafe.Pointer(&mem.temps)), m.Temps)
}

func (t _JointTempsTypeSupport) AsGoStruct(msg humble.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*JointTemps)
	mem := (*C.interbotix_xs_msgs__msg__JointTemps)(ros2_message_buffer)
	humble.StringSequenceToGo(&m.Names, *(*humble.CStringSequence)(unsafe.Pointer(&mem.names)))
	humble.Int32SequenceToGo(&m.Temps, *(*humble.CInt32Sequence)(unsafe.Pointer(&mem.temps)))
}

func (t _JointTempsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__interbotix_xs_msgs__msg__JointTemps())
}

type CJointTemps = C.interbotix_xs_msgs__msg__JointTemps
type CJointTempsSequence = C.interbotix_xs_msgs__msg__JointTemps__Sequence

func JointTempsSequenceToGo(goSlice *[]JointTemps, cSlice CJointTempsSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]JointTemps, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		JointTempsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func JointTempsSequenceToC(cSlice *CJointTempsSequence, goSlice []JointTemps) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.interbotix_xs_msgs__msg__JointTemps)(C.malloc(C.sizeof_struct_interbotix_xs_msgs__msg__JointTemps * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		JointTempsTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func JointTempsArrayToGo(goSlice []JointTemps, cSlice []CJointTemps) {
	for i := 0; i < len(cSlice); i++ {
		JointTempsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func JointTempsArrayToC(cSlice []CJointTemps, goSlice []JointTemps) {
	for i := 0; i < len(goSlice); i++ {
		JointTempsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
